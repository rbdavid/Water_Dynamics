#!/mnt/lustre_fs/users/mjmcc/apps/python2.7/bin/python
# ----------------------------------------
# USAGE:

# ----------------------------------------
# PREAMBLE:

import numpy as np
from numpy.linalg import *
import MDAnalysis
from MDAnalysis.analysis.align import *
from MDAnalysis.analysis.rms import *
import sys

# ----------------------------------------
# VARIABLE DECLARATION

pdb_file = sys.argv[1]
traj_loc = sys.argv[2]
start = int(sys.argv[3])
end = int(sys.argv[4])
system = sys.argv[5]

zeros = np.zeros
dot_prod = np.dot
#rmsd = MDAnalysis.analysis.align.rmsd
rmsd = MDAnalysis.analysis.rms.rmsd
sqrt = np.sqrt
flush = sys.stdout.flush

temp = start
traj_list = []
while temp <= end:
	traj_list.append('%sproduction.%s/dns3h.%s.prod.%s.dcd' %(traj_loc,temp,system,temp))
	temp += 1

# ----------------------------------------
# SUBROUTINES:
def ffprint(string):
	print '%s' %(string)
	flush()

# ----------------------------------------
# MAIN PROGRAM:

# ATOM SELECTION - load the pdb and traj into the desired MDAnalysis universe objects
ffprint('Loading in the universe')
u = MDAnalysis.Universe(pdb_file)
ref = MDAnalysis.Universe(pdb_file)

# Setting up the reference state to calculate the deviations from; in this instance, I am specifically interested in the ATP binding pocket and waters within/around the binding pocket
ref_atp_pocket = u.selectAtoms('protein and (resid 194:202 or resid 227 or resid 230:231 or resid 284:285 or resid 314 or resid 316 or resid 326 or resid 412:416 or resid 455:456 or resid 459:460 or resid 463)')		# untruncated trajectory
#ref_atp_pocket = u.selectAtoms('protein and (resid 27:35 or resid 60 or resid 63:64 or resid 117:118 or resid 147 or resid 149 or resid 159 or resid 245:249 or resid 288:289 or resid 292:293 or resid 296)')		# truncated trajectories
ref_atp_pocket.translate(-ref_atp_pocket.centerOfGeometry())
ref0 = ref_atp_pocket.coordinates()

# Setting up the universe object to be analyzed
u_all = u.selectAtoms('all')
tip3 = u.selectAtoms('resname TIP3')
atp_pocket = u.selectAtoms('protein and (resid 194:202 or resid 227 or resid 230:231 or resid 284:285 or resid 314 or resid 316 or resid 326 or resid 412:416 or resid 455:456 or resid 459:460 or resid 463)')		# untruncated trajectory
#atp_pocket = u.selectAtoms('protein and (resid 27:35 or resid 60 or resid 63:64 or resid 117:118 or resid 147 or resid 149 or resid 159 or resid 245:249 or resid 288:289 or resid 292:293 or resid 296)')		# truncated trajectories

nRes = len(tip3.residues)			# number of tip3 water residues
nAtoms = len(tip3.atoms)			# number of atoms in 'selection'
if nRes*3 != nAtoms:
	ffprint('Something is fucked up. Selection issues. nRes*3 != nAtoms...')

nAtoms0 = tip3.atoms[0].number
nRes0 = tip3.residues[0].resnum

# Variable declaration, prepping for distance calculations...
atp_atoms = len(atp_pocket.atoms)
distmin=0.0
distmax=25.0
total_count = 0.
dist_bins = zeros((100,2),dtype=float)
for i in range(100):
	dist_bins[i,0]=i*(distmax/100.)

# File Declaration
nRes_file = open('%s.nRes.dat' %(system), 'a',0)	# File to print out the number of residues within the binding pocket
res_num = open('%s.waters.dat' %(system), 'a',0)	# File to print out the atom numbers of the oxygen atom of TIP3 residues within the binding pocket selection
COG_file = open('%s.cog.xyz' %(system), 'a',0)		# File to print a vmd xyz trajectory showing the motion of the COG of the binding pocket selection
dis_file = open('%s.dist.dat' %(system), 'a',0)

ffprint('Beginning trajectory analysis')
# Loop through trajectory
for i in range(len(traj_list)):
	u.load_new(traj_list[i])
	ffprint('Working on Traj %d' %(start+i))

	for ts in u.trajectory:
		# obtain dimension values to be used for unwrapping atoms
		dimensions = zeros(3)
		dimensions2 = zeros(3)
		for i in range(3):
			dimensions[i] = u.dimensions[i]
			dimensions2[i] = dimensions[i]/2.0

		# Calculating and writing out to file the position of ATP pocket COG
		t = atp_pocket.centerOfGeometry()
		COG_file.write('1\n  generated by MDAnalysis and RBD\n C         %10.4f         %10.4f         %10.4f\n' %(t[0], t[1], t[2]))   #labeled the COG atom as a dummy atom, C...
		
		# Distance from COG histogram analysis 
		for i in range(atp_atoms):
			coor = atp_pocket.atoms[i].pos
			dist = 0.
			for j in range(3):
				temp = 0.
				temp = coor[j] - t[j]
				dist += temp*temp
			dist = sqrt(dist)
			k = 0
			while dist > dist_bins[k,0]:
				k += 1
			dist_bins[k,1] += 1.0
		
		# Align to reference (moves COG of the atp pocket to origin)
		u_all.translate(-t)

		# Fix any wrapping issues
		for i in range(0,nAtoms,3):
			# Calculate the COM of residues;
			COM = zeros(3)
			COM = tip3.atoms[i].pos
			# Declare the translational matrix to be used to move atoms back into the new unit cell
			trans = zeros(3)
			# Check to see if the residue needs to be wrapped
			for j in range(3):
				if COM[j] < -dimensions2[j]:
					trans[j] = dimensions[j]
				if COM[j] > dimensions2[j]:
					trans[j] = -dimensions[j]
			# translate the atoms of the residue using the translational matrix
			tip3.atoms[i:i+3].translate(trans)

		# Calculate the rotational matrix to align u to the ref
		R, rmsd = rotation_matrix(atp_pocket.coordinates(), ref0)
		# Apply rotation matrix to atoms within pocket_waters selection 
		u_all.rotate(R)

		# Calculate the new COG of atp pocket to use for new atom selection
		x, y, z = atp_pocket.centerOfGeometry()
		# create new atom selection and measure the instantaneous number of waters in binding pocket
		pocket_waters = u.selectAtoms('resname TIP3 and byres point %s %s %s 10.0' %(x, y, z)) 	# Atom selection for the waters within 10 angstroms of the binding pocket
		num_atom = len(pocket_waters.atoms)		# variable of the number of TIP3 atoms within the binding pocket selection
		nRes_file.write('%d\n' %(len(pocket_waters.residues)))		# Saving the number of TIP3 residues 

		# Printing out atom numbers for the oxygen atoms of TIP3 waters that are w/in the binding pocket
		for i in range(0,num_atom,3):
			res_num.write('%d    ' %(pocket_waters.atoms[i].number))                        # Saving the atom number of the oxygen atom for the corresponding TIP3 residue
		res_num.write('\n')

res_num.close()
COG_file.close()
nRes_file.close()

ffprint('Done with trajectory analysis.\n Beginning to analyze the output files...\n Starting by printing out results of distance from COG analysis.')
# Printing out distance values
for i in range(len(dist_bins)):
	dis_file.write('%10.3f %d\n' %(dist_bins[i,0],dist_bins[i,1]))
dis_file.close()

ffprint('Done with that.\n Starting long lived water and retention time analyses.')

ffprint('Reading in the waters file to analyze')
fo = open('%s.waters.dat' %(system), 'r')
bp = []
for line in fo:
	bp.append(line.split())
fo.close()

ffprint('Calculating the water retention.')
nSteps = len(bp)
overlap = zeros((nSteps,3),dtype=float)
for i in range(nSteps-1):
	temp = float(len(bp[i]))
	for j in range(i,nSteps):
		del_t = j-i
		inter = float(len(set(bp[i]).intersection(bp[j])))
		overlap[del_t,0] += 1
		overlap[del_t,1] += inter
		overlap[del_t,2] += inter/temp

ffprint('Print out the retention data and finding the set of waters that were in the binding pocket.')
waters_set = set()
nf = open('%s.wat_retention.dat' %(system),'w')
for i in range(nSteps):
	overlap[i,1] /= overlap[i,0]
	overlap[i,2] /= overlap[i,0]
	nf.write('%d    %d    %10.8f    %10.8f\n' %(i,overlap[i,0],overlap[i,1],overlap[i,2]))
	for j in range(len(bp[i])):
		waters_set.add(bp[i][j])
nf.close()

ffprint('Analyzing the set of waters for residence lifetimes and long-lived waters.')
waters = list(waters_set)
nf = open('%s.res_lifetime.dat' %(system), 'w')
mf = open('%s.long_lived.dat' %(system),'w')
mf.write('resname TIP3 and same residue as index ')
for i in range(len(waters)):
	j=0
	while j<nSteps:
		if (waters[i] in bp[j])==True:
			nf.write('%d    ' %(float(waters[i])))
			if j==0:
				nf.write('1   ')
			else:
				nf.write('0   ')
			dt=0
			if dt>=10:
				mf.write('%d ' %(waters[i]))
			if (j+dt)==nSteps:
				nf.write('1   ')
			else:
				nf.write('0   ')
			j+=dt+1
			nf.write('%d\n' %(dt))
		else:
			j+=1
nf.write('\n')
nf.close()
mf.close()

