#!/Library/Frameworks/Python.framework/Versions/2.7/bin/python
##!/mnt/lustre_fs/users/mjmcc/apps/python2.7/bin/python
# ----------------------------------------
# USAGE:

# ----------------------------------------
# PREAMBLE:

import sys
import numpy as np
from numpy.linalg import *
import MDAnalysis
from MDAnalysis.analysis.align import *
from distance_functions import *

zeros = np.zeros
dot_prod = np.dot
sqrt = np.sqrt
flush = sys.stdout.flush

# ----------------------------------------
# VARIABLE DECLARATION

config_file = sys.argv[1]

necessary_parameters = ['pdb','traj_loc','start','end','pocket_selection','pocket_radius','wat_resname']

all_parameters = ['pdb_file','prmtop_file','traj_file','pocket_selection','wat_resname','pocket_radius','number_of_wats_filename','wat_res_nums_filename','center_of_geometry_filename','correlation_filename','long_lived_wat_filename','Wrapped','water_OH_bond_dist','summary_bool','summary_filename','exclude_waters_bool','exclude_waters_selection','VMD_vis_bool','VMD_vis_filename','VMD_step']

# ----------------------------------------
# SUBROUTINES:

def ffprint(string):
	print '%s' %(string)
	flush()

def config_parser(config_file):	# Function to take config file and create/fill the parameter dictionary 
	for i in range(len(necessary_parameters)):
		parameters[necessary_parameters[i]] = ''

	# SETTING DEFAULT PARAMETERS FOR OPTIONAL PARAMETERS:
	parameters['wat_resname'] = 'WAT'
	parameters['pocket_radius'] = 6.0
	parameters['number_of_wats_filename'] = 'num_wats_pocket.dat'
	parameters['wat_res_nums_filename'] = 'res_nums_wats.dat'
	parameters['center_of_geometry_filename'] = 'COG_pocket.xyz'
	parameters['long_lived_wat_filename'] = 'long_lived_wats.vmd'
	parameters['Wrapped'] = True
	parameters['summary_bool'] = True
	parameters['summary_filename'] = 'water_diffusion_analysis.summary'
	parameters['VMD_vis_bool'] = False
	parameters['VMD_vis_filename'] = 'COG_vis_state.vmd'
	parameters['VMD_step'] = 100

	# GRABBING PARAMETER VALUES FROM THE CONFIG FILE:
	execfile(config_file,parameters)
	for key, value in parameters.iteritems():
		if value == '':
			print '%s has not been assigned a value. This variable is necessary for the script to run. Please declare this variable within the config file.' %(key)
			sys.exit()

def summary(filename):
	with open(filename,'w') as W:
		W.write('Using MDAnalysis version: %s\n' %(MDAnalysis.version.__version__))
		W.write('To recreate this analysis, run this line:\n')
		for i in range(len(sys.argv)):
			W.write('%s ' %(sys.argv[i]))
		W.write('\n\nParameters used:\n')
		for i in all_parameters:
			W.write('%s = %s \n' %(i,parameters[i]))
		W.write('\n\n')

# ----------------------------------------
# MAIN:
# CREATING PARAMETER DICTIONARY
parameters = {}
config_parser(config_file)

# ----------------------------------------
# LOADING IN ANALYSIS UNIVERSE AND CREATING THE NECESSARY ATOM SELECTIONS
ffprint('Loading Analysis Universe.')
u = MDAnalysis.Universe(parameters['prmtop_file'],parameters['pdb_file'])
u_all = u.select_atoms('all')
wat = u.select_atoms('resname %s' %(parameters['wat_resname']))
u_pocket = u.select_atoms(parameters['pocket_selection'])

ffprint('Grabbing the Positions of the Binding Pocket to use as reference.')
u_all.translate(-u_pocket.center_of_geometry())
pocket_ref = u_pocket.positions

nWats = wat.n_residues			# number of water residues
nRes0 = wat.residues[0].resid		# residue index is 0 indexed 

if nWats*3 != wat.n_atoms:
	ffprint('nWats*3 != wat.n_atoms. Unexpected number of water atoms. Possible selection error with water residue name.')
	sys.exit()

# ----------------------------------------
# MEMORY DECLARATION

# ----------------------------------------
# TRAJECTORY ANALYSIS 
start = int(parameters['start'])
end = int(parameters['end'])
res_nums = []
nSteps = 0
with open(parameters['number_of_wats_filename'],'w') as X, open(parameters['wat_res_nums_filename'],'w') as Y, open(parameters['center_of_geometry_filename'],'w') as Z:
	ffprint('Beginning trajectory analysis')
	while start <= end:
		ffprint('Loading trajectory %s' %(start))
		u.load_new('%sproduction.%s/production.%s.dcd' %(parameters['traj_loc'],start,start))
		nSteps += len(u.trajectory)
		# Loop through trajectory
		for ts in u.trajectory:
			t = u_pocket.center_of_geometry()
			
			if ts.frame%parameters['COG_delta_write'] == 0:
				Z.write('1\n  generated by MDAnalysis and RBD; traj %d frame %d\n X         %10.4f         %10.4f         %10.4f\n' %(start,ts.frame+1,t[0], t[1], t[2]))	#Writing an xyz trajectory of the center of geometry of the binding pocket; the COG particle is labeled as a dummy atom X
			
			u_all.translate(-t)	# Align to reference (moves COG of the pocket to origin)
	
			if not parameters['Wrapped']:
				dims = u.dimensions[:3]	# obtain dimension values to be used for wrapping atoms
				dims2 = dims/2.0
				for i in range(nWats):
					temp = wat.reidues[i].atom[0].position
					t = wrapping(temp,dims,dims2)
					wat.residues[i].translate(t)
	
			R, rmsd = rotation_matrix(u_pocket.positions,pocket_ref)	# Calculate the rotational matrix to align u to the ref, using the pocket selection as the reference selection
			u_all.rotate(R)
		
			pocket_waters = wat.select_atoms('byres point 0 0 0 %d' %(parameters['pocket_radius'])) # Atom selection for the waters within radius angstroms of the COG of the pocket; Assumes that the COG of the pocket is at 0,0,0 xyz coordinates (which it should be bc the translational motion of the pocket is removed...)
			
			nRes = pocket_waters.n_residues		# Calculate the number of waters within the pocket volume
			X.write('%d\n' %(nRes))		# Outputting the number of water residues at timestep ts

			res_nums.append(list(set(pocket_waters.resids)))

			for i in range(nRes):
				res = pocket_waters.residues[i]	
				Y.write('%d   ' %(res.resid))	
			Y.write('\n')

ffprint('Done with saving residue numbers of binding pocket waters.\nBeginning retention lifetime calculations.')

# ------------------------------------------
# 

if nSteps != len(res_nums):
	print 'Number of steps does not equal the number of elements within the res_nums, indicating a timestep where no waters are found in the binding pocket. At the moment, this is assumed to be a bad result.'
	sys.exit()

retention_array = np.zeros((nSteps,3),dtype=np.float64)
for i in range(nSteps):		# Looping through all timesteps
	temp_num_wats = len(res_nums[i])
	for j in range(temp_num_wats):
		dt = 1
		while i+dt<nSteps and res_nums[i][j] in res_nums[i+dt]:
			retention_array[dt,0] += 1
			retention_array




for i in range(nSteps-1):
	temp = len(res_nums[i])
	for j in range(i,nSteps):
		delta_t = j - i
		retention = len(res_nums[i].intersection(res_nums[j]))
		retention_array[delta_t,0] += 1				# counter of number of delta_t instances
		retention_array[delta_t,1] += float(retention)		# number of waters that remained in the binding pocket between delta_t
		retention_array[delta_t,2] += float(retention/temp)





# ------------------------------------------
# ANALYSIS OF TRAJECTORY DATA - MSD AND O-H BOND AUTOCORRELATION AND LONG-LIVED WATER RESIDUES

long_lived = set()
for i in range(nWats):		# Looping through all water residues.
	for j in range(nSteps):	# Looping through all timesteps for a single water.
		if oxygen_Coord[j,i,0] == oxygen_Coord[j,i,0]:	# boolean test to see if array object has a nan value or not; nan values will not equate and produce a FALSE;
			dt=1
			pos0 = oxygen_Coord[j,i,:]
			vec0 = OH_vector[j,i,:]
			while (j+dt)<nSteps and oxygen_Coord[j+dt,i,0] == oxygen_Coord[j+dt,i,0]:	# 
				if dt == 200 and i+nRes0+1 not in long_lived:	# the water molecule has resided in the pocket for 200 frames (or more) AND has not been added to the set already;
					long_lived.add(i+nRes0+1)	# saving the one-indexed residue index for long-lived water molecules 
				
				pos1 = oxygen_Coord[j+dt,i,:]
				vec1 = OH_vector[j+dt,i,:]

				dist, dist2 = euclid_dist(pos0,pos1)	# Calculates the MSD of the oxygen atoms in the water molecule
				scalar_product = dot_prod(vec0,vec1)

				correlation_data[dt,0]+=1		# count array element
				correlation_data[dt,1]+= dist2	# sum of MSD values
				correlation_data[dt,2]+= dist2**2	# sum of MSD^2 values
				correlation_data[dt,3]+= scalar_product
				dt+=1			# increment the dt value

ffprint('Finished with dist2 calculations. Beginning to average and print out msd values')

# ----------------------------------------
# OUTPUTTING DATA TO FILE

with open(parameters['correlation_filename'],'w') as W:
	for i in range(1,nSteps):
		if correlation_data[i,0]>1.0:
			correlation_data[i,1]/=correlation_data[i,0]	# Finish the average of the MSD value for the dt
			correlation_data[i,2]/=correlation_data[i,0]	# Finish the average of the MSD^2 value for the dt
			correlation_data[i,3]/=correlation_data[i,0]	# Finish the average of the Velocity*Velocity autocorrelation 
		W.write('%10.d   %10.d   %10.6f   %10.6f   %10.6f \n' %(i,correlation_data[i,0],correlation_data[i,1],correlation_data[i,2],correlation_data[i,3]))

ffprint('Writing the unique TIP3 oxygen numbers that are found to be within the binding pocket for longer than 200 frames.')
with open(parameters['long_lived_wat_filename'],'w') as W:
	ll_list = list(long_lived)
	W.write('resid ')
	for i in range(len(ll_list)):
		W. write('%d '%(ll_list[i]))
	W.write('\n')

# ----------------------------------------
# OUTPUTTING VMD VIS STATE FILE

if parameters['VMD_vis_bool']:
	with open(parameters['VMD_vis_filename'],'w') as W:
		W.write('# VMD Visualization State - COG of protein pocket within which water dynamics are analyzed; Written by RBD\n# Load into VMD using "vmd -e %s \n\nmol new %s\n mol addfile %s step %d\n mol modselect 0 0 "protein"\n mol modstyle 0 0 "NewCartoon"\n\n mol new %s step %d\n set sel [atomselect top "name X"]\n $sel set radius %d\nmol modselect 0 1 "name X"\n mol modstyle 0 1 "VDW"\n mol modmaterial 0 1 "Transparent"\n mol modcolor 0 1 "ColorID 23"\n\n'%(parameters['VMD_vis_filename'],parameters['prmtop_file'],parameters['traj_file'],parameters['VMD_step'],parameters['center_of_geometry_filename'],parameters['VMD_step'],parameters['pocket_radius']))

# ----------------------------------------
# OUTPUTTING SUMMARY OF THE ANALYSIS
if parameters['summary_bool']:
	summary(parameters['summary_filename'])

